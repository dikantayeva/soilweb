<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soil Moisture Dashboard MVP</title>
    <!-- 
        CSS-стили имитируют Tailwind CSS. 
    -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Подключение Leaflet CSS (Удален integrity для обхода локальных ошибок) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        crossorigin=""/>
    <style>
        /* =======================================================
           ОСНОВНЫЕ СТИЛИ (ИМИТАЦИЯ TAILWIND)
           ======================================================= */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc; 
            padding: 2rem; 
            min-height: 100vh;
        }
        header { margin-bottom: 1.5rem; }
        h1 {
            font-size: 1.875rem; 
            font-weight: 700; 
            color: #1f2937; 
        }
        .text-gray-500 { color: #6b7280; }
        .grid {
            display: grid;
            gap: 1.5rem; 
            grid-template-columns: 1fr;
        }
        @media (min-width: 1024px) { 
            .grid { grid-template-columns: repeat(3, 1fr); }
            .lg\:col-span-2 { grid-column: span 2 / span 2; }
            .lg\:col-span-1 { grid-column: span 1 / span 1; }
        }
        /* Стили для контейнера карты */
        #map {
            height: 80vh; 
            min-height: 500px; 
            border-radius: 0.75rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            z-index: 1; 
        }
        /* Стили для боковой панели */
        .sidebar {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .sidebar h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }
        /* Контейнер для 3D */
        #threeD-container {
            width: 100%;
            height: 400px; 
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            background-color: #dbeafe; 
            border: 1px solid #93c5fd;
            position: relative;
        }
        #threeD-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Стиль для инфо-панели 3D (Popup) */
        #threeD-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: none; 
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }
        /* Индикатор выбранного здания */
        #building-status {
            font-weight: 600;
            padding: 0.5rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            text-align: center;
            background-color: #fffbeb; 
            color: #b45309; 
            border: 1px solid #fcd34d;
        }

        .control-group {
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        .bg-blue-50 { background-color: #eff6ff; }
        .text-blue-800 { color: #1e40af; }
        .bg-green-50 { background-color: #ecfdf5; }
        .text-green-800 { color: #065f46; }

        /* Стиль для элементов управления */
        input[type="date"], input[type="range"] {
            width: 100%;
            margin-top: 0.25rem;
            padding: 0.5rem;
            border: 1px solid #bfdbfe;
            border-radius: 0.375rem;
        }
        
        /* Стиль для маркеров зданий (Яркая рамка для видимости) */
        .custom-building-icon div {
            z-index: 1000;
            background-color: #333333; 
            color: white; 
            border-radius: 5px; 
            padding: 5px 8px; 
            font-weight: bold; 
            font-size: 14px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.5); 
            cursor: pointer; 
            border: 2px solid #ff00ff; /* Фиолетовая рамка */
        }
        .custom-building-icon-selected div {
            background-color: #007bff;
            border: 3px solid #00ff00 !important; /* Зеленая рамка для выделения */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <header class="mb-6">
        <h1 class="text-3xl font-bold text-gray-800">Soil-Moisture Monitoring Dashboard</h1>
        <p class="text-gray-500">Визуализация данных датчиков влажности в реальном времени (Астана).</p>
    </header>

    <div class="grid">

        <!-- Основной блок - Карта -->
        <div class="lg:col-span-2">
            <div id="map"></div>
        </div>

        <!-- Боковая панель - Управление и 3D-визуализация -->
        <div class="lg:col-span-1 sidebar">
            <h2>3D Разрез Уровней Здания</h2>
            <div id="building-status">
                Выбрано здание: H-001
            </div>

            <!-- Контейнер для 3D-визуализации -->
            <div id="threeD-container">
                <!-- Панель для отображения данных при наведении в 3D -->
                <div id="threeD-info"></div>
            </div>

            <!-- Элементы управления для Этапа 5: Календарь и Ползунок -->
            <div id="controls-placeholder" class="space-y-4">
                <div class="control-group bg-blue-50">
                    <p class="font-medium text-blue-800">Календарь выбора даты</p>
                    <input type="date" id="date-picker" value="2025-11-23" 
                           class="w-full mt-1 p-2 border border-blue-200 rounded-md" 
                           onchange="refreshDashboard()">
                </div>
                <div class="control-group bg-green-50">
                    <p class="font-medium text-green-800">Ползунок часа</p>
                    <input type="range" min="0" max="23" value="12" id="hour-slider" 
                           class="w-full mt-2" 
                           oninput="document.getElementById('hourValue').innerText=this.value.padStart(2, '0') + ':00'; refreshDashboard()">
                    <span id="hourValue" class="text-sm font-mono text-green-700 block text-right">12:00</span>
                </div>
            </div>
        </div>
    </div>

    <!-- 
        ОБЯЗАТЕЛЬНО: Подключаем Leaflet JS
    -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    
    <!-- 
        ОБЯЗАТЕЛЬНО: Подключаем Three.js и OrbitControls (для управления камерой мышью)
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // =======================================================
        // I. ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И НАСТРОЙКИ (main.js)
        // =======================================================
        let map;
        const API_URL = 'http://localhost:3000/api/sensors'; 
        let allSensors = []; 
        let selectedHouseId = 'H-001'; 

        // THREE.JS VARIABLES
        let scene, camera, renderer, controls, raycaster;
        let INTERSECTED; 
        const NUM_LEVELS = 6;
        const LEVEL_HEIGHT = 5; 
        const LEVEL_SIZE = 100; 
        const GRID_SEGMENTS = 20; 

        // Фиксированные позиции датчиков для 4 углов каждого уровня (X, Z)
        const FIXED_SENSOR_POSITIONS = [
            { X: 0, Z: 0, idSuffix: '-1' },
            { X: LEVEL_SIZE, Z: 0, idSuffix: '-2' },
            { X: 0, Z: LEVEL_SIZE, idSuffix: '-3' },
            { X: LEVEL_SIZE, Z: LEVEL_SIZE, idSuffix: '-4' }
        ];


        // =======================================================
        // II. LEAFLET (КАРТА) ЛОГИКА (initializeMap.js)
        // =======================================================
        
        /**
         * Инициализирует карту Leaflet
         */
        function initializeMap() {
            if (typeof L === 'undefined') {
                console.error("КРИТИЧЕСКАЯ ОШИБКА: Объект L (Leaflet) не загружен. Проверьте CDN.");
                return;
            }

            const mapElement = document.getElementById('map');
            if (!mapElement) {
                console.error("КРИТИЧЕСКАЯ ОШИБКА: Элемент #map не найден в DOM.");
                return;
            }

            const initialCoords = [51.169392, 71.449074]; 
            const initialZoom = 14;
            
            if (map) {
                map.remove(); 
            }

            map = L.map('map').setView(initialCoords, initialZoom);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 18,
            }).addTo(map);

            console.log("1.1. Карта Leaflet успешно инициализирована.");
        }

        /**
         * Определяет стиль для маркера датчика
         */
        function getSensorStyle(sensorData) {
            const { moisture, isEpicenter } = sensorData;

            let color;
            if (moisture < 40) {
                color = '#22c55e'; // Green
            } else if (moisture < 70) {
                color = '#f59e0b'; // Yellow
            } else {
                color = '#ef4444'; // Red
            }

            if (isEpicenter) {
                color = '#dc2626'; // Bright Red
            }

            const radius = 8 + (moisture / 20);

            return {
                radius: isEpicenter ? 18 : radius,
                fillColor: color,
                color: isEpicenter ? '#000000' : '#ffffff', 
                weight: isEpicenter ? 2 : 1,
                opacity: 1,
                fillOpacity: 0.9
            };
        }

        /**
         * Создает HTML-контент для всплывающего окна
         */
        function createPopupContent(sensorData) {
            const { sensorId, level, moisture, timestamp, isEpicenter } = sensorData;
            const date = new Date(timestamp);

            return `
                <div style="padding: 0.5rem; font-family: monospace; font-size: 0.875rem;">
                    <h3 style="font-size: 1rem; font-weight: bold; color: #1f2937; margin-bottom: 0.25rem;">${sensorId} (${level})</h3>
                    <p style="margin-bottom: 0.25rem;">
                        Влажность: <span style="font-weight: 600; font-size: 1.125rem; color: ${moisture > 70 ? '#dc2626' : '#10b981'};">${moisture}%</span>
                    </p>
                    <p style="color: #6b7280;">
                        Время: ${date.toLocaleTimeString('ru-RU')} ${date.toLocaleDateString('ru-RU')}
                    </p>
                    ${isEpicenter ? '<div style="margin-top: 0.5rem; font-weight: bold; color: white; background-color: #dc2626; padding: 0.25rem 0.5rem; border-radius: 9999px; display: inline-block; font-size: 0.75rem;">❗ ЭПИЦЕНТР</div>' : ''}
                </div>
            `;
        }

        /**
         * Отображает все датчики на карте
         */
        function renderSensorsOnMap(sensors) {
            if (!map) {
                 console.error("3. Ошибка рендеринга: Карта 'map' не инициализирована.");
                 return;
            }

            // Удаляем старые маркеры датчиков
            map.eachLayer(function (layer) {
                if (layer.options.isSensor) {
                    map.removeLayer(layer);
                }
            });

            console.log(`3.1. Отображение ${sensors.length} датчиков на карте (для выбранного здания).`);
            
            sensors.forEach(sensor => {
                const style = getSensorStyle(sensor);

                // Отрисовываем только те датчики, которые относятся к текущему выбранному зданию
                if (sensor.houseId !== selectedHouseId) return;

                const marker = L.circleMarker([sensor.lat, sensor.lng], { ...style, isSensor: true, pane: 'markerPane' }) 
                    .addTo(map)
                    .bindPopup(createPopupContent(sensor), { closeButton: false, autoPan: false });

                marker.on('mouseover', function (e) { this.openPopup(); });
                marker.on('mouseout', function (e) { this.closePopup(); });
            });
        }
        
        /**
         * Отображает маркеры зданий на карте
         */
        function renderBuildingsOnMap(sensors) {
            if (!map) return;

            // Удаляем старые маркеры зданий
            map.eachLayer(function (layer) {
                if (layer.options.isBuilding) {
                    map.removeLayer(layer);
                }
            });

            // Группируем датчики по зданию для определения координат здания
            const houses = sensors.reduce((acc, sensor) => {
                if (!acc[sensor.houseId]) {
                    // Используем координаты первого датчика как центр здания
                    acc[sensor.houseId] = {
                        houseId: sensor.houseId,
                        lat: sensor.lat, 
                        lng: sensor.lng,
                    };
                }
                return acc;
            }, {});

            Object.values(houses).forEach(house => {
                const isSelected = house.houseId === selectedHouseId;
                
                let iconClassName = 'custom-building-icon';
                if (isSelected) {
                    iconClassName += ' custom-building-icon-selected';
                }
                
                const iconHtml = `<div>${house.houseId}</div>`;

                const customIcon = L.divIcon({
                    className: iconClassName,
                    html: iconHtml,
                    iconAnchor: [15, 15]
                });

                const marker = L.marker([house.lat, house.lng], { 
                    icon: customIcon, 
                    isBuilding: true, 
                    houseId: house.houseId,
                    zIndexOffset: isSelected ? 1000 : 500 
                })
                    .addTo(map)
                    .bindPopup(`Здание: ${house.houseId}. Кликните для 3D-разреза.`, { closeButton: false, autoPan: false });

                // ОБРАБОТЧИК КЛИКА: Выбирает здание и обновляет 3D-сцену
                marker.on('click', function (e) {
                    selectBuilding(house.houseId);
                    map.closePopup(marker.getPopup());
                });
            });
            
            // Центрируем карту на выбранном здании при первой загрузке
            if (!map && !map.isFirstLoad) { 
                 const selectedHouse = Object.values(houses).find(h => h.houseId === selectedHouseId);
                 if (selectedHouse) {
                     map.setView([selectedHouse.lat, selectedHouse.lng], 16); 
                 }
                 map.isFirstLoad = true;
            }
        }
        
        /**
         * Выбирает здание для 3D-визуализации
         */
        function selectBuilding(houseId) {
            selectedHouseId = houseId;
            document.getElementById('building-status').innerText = `Выбрано здание: ${houseId}`;
            
            // Обновляем стили маркеров на карте
            renderBuildingsOnMap(allSensors); 
            
            // Обновляем 3D-сцену и карту с учетом нового выбранного здания
            refreshDashboard(); 
        }


        // =======================================================
        // III. THREE.JS (3D) ЛОГИКА (initialize3D.js)
        // =======================================================
        
        /**
         * Реализует упрощенную интерполяцию (IDW) для симуляции Kriging
         */
        function simplifiedInterpolation(x, y, sensorsOnLevel) {
            if (sensorsOnLevel.length < 2) return 50; 
            
            let sumWeightMoisture = 0;
            let sumWeight = 0;
            const power = 2; 

            sensorsOnLevel.forEach(sensor => {
                const sensorX = sensor.X;
                const sensorY = sensor.Z; 
                
                const dx = x - sensorX;
                const dy = y - sensorY;
                const distanceSq = dx * dx + dy * dy;
                
                if (distanceSq < 0.01) {
                    sumWeightMoisture = sensor.moisture;
                    sumWeight = 1;
                    return; 
                }

                const weight = 1 / Math.pow(Math.sqrt(distanceSq), power); 

                sumWeightMoisture += weight * sensor.moisture;
                sumWeight += weight;
            });

            return sumWeight > 0 ? Math.min(100, Math.max(0, sumWeightMoisture / sumWeight)) : 50;
        }

        /**
         * Добавляет "волну влажности" (сетчатую поверхность) на уровень
         */
        function createMoistureWave(levelIndex, sensorsForLevel) {
            const geometry = new THREE.PlaneGeometry(LEVEL_SIZE, LEVEL_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);
            
            const offset = LEVEL_SIZE / 2;
            const yPos = -levelIndex * LEVEL_HEIGHT; 
            
            const color = new THREE.Color();
            const maxMoisture = 100;
            
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3));

            for (let i = 0; i < geometry.attributes.position.count; i++) {
                const vertex = new THREE.Vector3();
                vertex.fromBufferAttribute(geometry.attributes.position, i);
                
                const xWorld = vertex.x + offset; 
                const zWorld = vertex.y + offset; 
                
                const interpolatedMoisture = sensorsForLevel.length > 0 ? simplifiedInterpolation(xWorld, zWorld, sensorsForLevel) : 50;
                
                const ratio = interpolatedMoisture / maxMoisture;
                color.setHSL(0.33 * (1 - ratio), 1.0, 0.5); 

                geometry.attributes.color.setXYZ(i, color.r, color.g, color.b);
                
                const heightOffset = (interpolatedMoisture / maxMoisture) * 0.5; 
                geometry.attributes.position.setZ(i, vertex.z + heightOffset); 
            }
            
            geometry.attributes.position.needsUpdate = true; 

            const waveMaterial = new THREE.MeshBasicMaterial({ 
                vertexColors: true, 
                transparent: true, 
                opacity: 0.6, 
                side: THREE.DoubleSide
            });

            const waveMesh = new THREE.Mesh(geometry, waveMaterial);
            waveMesh.rotation.x = -Math.PI / 2; 
            waveMesh.position.set(LEVEL_SIZE / 2, yPos + 0.1, LEVEL_SIZE / 2); 
            waveMesh.userData.isWave = true;
            waveMesh.userData.levelName = `L-${levelIndex + 1}`;
            scene.add(waveMesh);
        }

        /**
         * Добавляет датчики в 3D-сцену (4 датчика по углам)
         */
        function renderSensorsIn3D(sensors) {
            // Удаляем старые объекты (волны и датчики)
            const oldObjects = scene.children.filter(obj => obj.userData.isSensor || obj.userData.isWave);
            oldObjects.forEach(obj => scene.remove(obj));

            const maxMoisture = 100; 
            const sensorGeometry = new THREE.SphereGeometry(2, 16, 16); 

            // Группируем полученные данные по уровням
            const sensorsMap = sensors.reduce((map, s) => {
                map[s.level] = map[s.level] || {};
                // Используем суффикс ID (1, 2, 3, 4) для сопоставления с FIXED_SENSOR_POSITIONS
                const idSuffix = s.sensorId.split('-').pop(); 
                map[s.level][idSuffix] = s;
                return map;
            }, {});

            for (let i = 0; i < NUM_LEVELS; i++) {
                const levelName = `L-${i + 1}`;
                const sensorsOnLevelMap = sensorsMap[levelName] || {};
                const sensorsForWave = []; 

                const yPos = -i * LEVEL_HEIGHT; 

                // Проходим по фиксированным позициям (углам)
                FIXED_SENSOR_POSITIONS.forEach(pos => {
                    const sensorIdKey = pos.idSuffix;
                    const sensorData = sensorsOnLevelMap[sensorIdKey];

                    // Мы рисуем датчик, только если для этого угла (sensorIdKey) есть данные
                    if (sensorData) {
                        // 1. Подготовка данных для волны
                        sensorsForWave.push({
                            ...sensorData,
                            X: pos.X, // Используем X из угла
                            Z: pos.Z  // Используем Z из угла
                        });

                        // 2. Отрисовка датчика
                        const colorVal = sensorData.moisture / maxMoisture;
                        const color = new THREE.Color(0x22c55e).lerp(new THREE.Color(0xef4444), colorVal);
                        
                        const material = new THREE.MeshLambertMaterial({ color: color.getHex() });
                        const mesh = new THREE.Mesh(sensorGeometry, material);
                        
                        mesh.position.set(pos.X, yPos + 0.5, pos.Z); 
                        
                        if (sensorData.isEpicenter) {
                            mesh.scale.set(1.5, 1.5, 1.5); 
                            material.emissive = new THREE.Color(0x990000); 
                            material.color.setHex(0xFF0000); 
                        }

                        mesh.userData = {
                            ...sensorData,
                            isSensor: true,
                            originalColor: material.color.getHex()
                        };

                        scene.add(mesh);
                    }
                });
                
                // 3. Создание Волны Влажности (Интерполяция)
                createMoistureWave(i, sensorsForWave);
            }
            console.log("4.1. Датчики и волна влажности отрисованы в 3D-сцене.");
        }
        
        /**
         * Инициализирует 3D-сцену Three.js
         */
        function initialize3D() {
            const container = document.getElementById('threeD-container');
            if (!container) return;

            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdbeafe); 

            // 2. Camera (Perspective Camera)
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(LEVEL_SIZE * 0.8, LEVEL_HEIGHT * NUM_LEVELS * 1.5, LEVEL_SIZE * 1.5); 
            
            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(LEVEL_SIZE, LEVEL_HEIGHT * NUM_LEVELS, LEVEL_SIZE);
            scene.add(directionalLight);

            // 5. Controls (для вращения/масштабирования мышью)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(LEVEL_SIZE / 2, -LEVEL_HEIGHT * NUM_LEVELS / 2, LEVEL_SIZE / 2); // Центр 3D модели
            controls.update();

            // 6. Raycaster для наведения курсора
            raycaster = new THREE.Raycaster();
            container.addEventListener('mousemove', onDocumentMouseMove, false);
            
            // 7. Handle Resize
            window.addEventListener('resize', onWindowResize, false);

            // 8. Start Animation Loop
            animate();
        }

        /**
         * Обработчик изменения размеров окна
         */
        function onWindowResize() {
            const container = document.getElementById('threeD-container');
            if (container && camera && renderer) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        /**
         * Создает 6 горизонтальных уровней в виде боксов
         */
        function createLevels() {
            // Удаляем старые объекты (уровни)
            const objectsToRemove = scene.children.filter(obj => obj.userData.isLevel);
            objectsToRemove.forEach(obj => scene.remove(obj));

            const boxDepth = LEVEL_HEIGHT / 10; 
            const levelMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc, transparent: true, opacity: 0.3 });

            for (let i = 0; i < NUM_LEVELS; i++) {
                const yPos = -i * LEVEL_HEIGHT; 
                
                // 1. Горизонтальный прямоугольник (Уровень)
                const planeGeometry = new THREE.BoxGeometry(LEVEL_SIZE, boxDepth, LEVEL_SIZE);
                const plane = new THREE.Mesh(planeGeometry, levelMaterial);
                
                plane.position.set(LEVEL_SIZE / 2, yPos, LEVEL_SIZE / 2);
                
                plane.userData.isLevel = true; 
                plane.userData.levelName = `L-${i + 1}`;
                scene.add(plane);
                
                console.log(`Уровень L-${i + 1} создан на Y=${yPos}`);
            }
        }
        
        /**
         * Обработчик движения мыши для Raycasting (наведение на датчики)
         */
        function onDocumentMouseMove(event) {
            event.preventDefault();

            const container = document.getElementById('threeD-container');
            
            const mouse = new THREE.Vector2();
            mouse.x = ( (event.clientX - container.getBoundingClientRect().left) / container.clientWidth ) * 2 - 1;
            mouse.y = - ( (event.clientY - container.getBoundingClientRect().top) / container.clientHeight ) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children.filter(obj => obj.userData.isSensor));
            const infoPanel = document.getElementById('threeD-info');

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const newIntersected = intersect.object;
                
                if (INTERSECTED != newIntersected) {
                    if (INTERSECTED) {
                        INTERSECTED.material.emissive.setHex(INTERSECTED.userData.isEpicenter ? 0x990000 : 0x000000);
                        INTERSECTED.material.color.setHex(INTERSECTED.userData.originalColor);
                    }
                    
                    INTERSECTED = newIntersected;
                    INTERSECTED.material.emissive.setHex(0x00ff00); 

                    const data = INTERSECTED.userData;
                    infoPanel.innerHTML = `
                        ID: ${data.sensorId}<br>
                        Уровень: ${data.level}<br>
                        Влажность: ${data.moisture}%<br>
                        ${data.isEpicenter ? 'ЭПИЦЕНТР' : ''}
                    `;
                    infoPanel.style.opacity = 1;
                    
                }
            } else {
                if (INTERSECTED) {
                    INTERSECTED.material.emissive.setHex(INTERSECTED.userData.isEpicenter ? 0x990000 : 0x000000);
                    INTERSECTED.material.color.setHex(INTERSECTED.userData.originalColor);
                }
                INTERSECTED = null;
                infoPanel.style.opacity = 0;
            }
        }
        
        /**
         * Анимационный цикл Three.js
         */
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); 
            if (renderer && scene && camera) renderer.render(scene, camera);
        }


        // =======================================================
        // IV. ГЛАВНАЯ ЛОГИКА (main.js)
        // =======================================================
        
        /**
         * Асинхронно получает данные датчиков с сервера
         */
        async function fetchSensorData(date, hour, houseId) {
            // houseId пустой для получения всех данных на первом шаге
            const houseQuery = houseId ? `&houseId=${houseId}` : '';
            const url = `${API_URL}?date=${date}&hour=${hour}${houseQuery}`; 
            
            try {
                console.log(`2. Запрос данных по API: ${url}`);
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
                
            } catch (error) {
                console.error("КРИТИЧЕСКАЯ ОШИБКА: Не удалось получить данные с сервера (Node.js). Убедитесь, что 'node server.js' запущен.", error);
                return [];
            }
        }


        /**
         * Главная функция для обновления дашборда (Карта + 3D)
         */
        async function refreshDashboard() {
            console.log("4. Обновление дашборда (Карта и 3D)...");
            
            const date = document.getElementById('date-picker').value;
            const hour = document.getElementById('hour-slider').value;
            
            // 1. Запрашиваем все данные с сервера
            const allFetchedSensors = await fetchSensorData(date, hour, ''); 
            
            // 2. Обновление allSensors всеми данными
            allSensors = allFetchedSensors; 
            
            // 3. Рендеринг зданий на карте
            renderBuildingsOnMap(allSensors);
            
            // 4. Фильтрация и рендеринг датчиков на карте (только для выбранного здания)
            renderSensorsOnMap(allSensors); 
            
            // 5. Фильтрация данных для 3D и рендеринг
            const sensorsFor3D = allFetchedSensors.filter(s => s.houseId === selectedHouseId);
            if (scene) {
                renderSensorsIn3D(sensorsFor3D); 
            }
        }

        // Автоматический запуск после того, как DOM и скрипты будут готовы
        document.addEventListener('DOMContentLoaded', () => {
            console.log("1. Попытка инициализации Leaflet...");
            initializeMap();
            initialize3D();
            createLevels(); 
            
            // Запуск обновления дашборда
            setTimeout(() => {
                 refreshDashboard(); 
                 if (map) map.invalidateSize(); 
            }, 100); 
        });
    </script>
</body>
</html>